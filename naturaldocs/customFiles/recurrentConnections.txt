Title: Average Behaviour  

This tutorial introduces using the CGP-Library to create recurrent programs.

Recurrent programs are those which can contain feedback allowing CGP chromosomes to describe cyclic as well as acyclic graphs. The ability to describe cyclic programs allows CGP to be applied to partially observable tasks through the ablity to hold internal state information. Recurrent Cartesian Genetic Programming (RCGP) and can create recurrent equations, boolean logic state machines and recurrent artificial neural networks.

This tutorial closely follows the <Getting Started> tutorial and it is recommended that you read that tutorial first.

Title: The Program

A simple program illustrating using CGP-Library to create recurrent equations.

The program below is provided in the CGP-Library download within /examples/recurrentConnections.c and is included in the code:blocks project. 

#include <stdio.h>
#include "../src/cgp.h"

int main(void){

	struct parameters *params = NULL;
	struct dataSet *trainingData = NULL;
	struct chromosome *chromo = NULL;

	int numInputs = 1;
	int numNodes = 15;
	int numOutputs = 1;
	int nodeArity = 2;
	
	int numGens = 100000;
	double targetFitness = 0.1;
	int updateFrequency = 500;
	
	double recurrentConnectionProbability = 0.10;

	params = initialiseParameters(numInputs, numNodes, numOutputs, nodeArity);

	addNodeFunction(params, "add,sub,mul,div");

	setTargetFitness(params, targetFitness);

	setUpdateFrequency(params, updateFrequency);

	setRecurrentConnectionProbability(params, recurrentConnectionProbability);

	printParameters(params);

	trainingData = initialiseDataSetFromFile("./dataSets/fibonacci.data");

	chromo = runCGP(params, trainingData, numGens);

	printChromosome(chromo, 0);

	removeInactiveNodes(chromo);
	
	saveChromosomeDot(chromo, 0, "temp.dot");

	freeDataSet(trainingData);
	freeChromosome(chromo);
	freeParameters(params);

	return 0;
}
(end)

Title: Stepping Through the Code

A close look at the code.

The above code is very similar to gettingStarted.c seen in the <Getting Started> tutorial and shall not be explained again. Here the specifics relating to recurrent connections shall be highlighted. 














When CGP is repeatedly applied to a given task using <repeatCGP> the results are stored in a returned <results> structure. Therefore we need to define a <results> structure variable to store the returned <results>. An averageFitness variable is also defined which will later store the average fitness achieved when repeatedly applying CGP to the given task multiple times.

(begin code)
struct results *rels = NULL;
...
double averageFitness;
(end)

When assessing the average behaviour of CGP towards a given task CGP must be applied to that task a number of times. Each instance of applying CGP towards the task is called a run. Here the numRuns variable stores the number of runs CGP will be applied towards the given task.

(begin code)
int numRuns = 10;
(end)

In the <Getting Started> tutorial we applied CGP to the given task once using <runCGP>. Here we are repeatedly applying CGP to a give task using <repeatCGP>. The parameters of <repeatCGP> are the same as for <runCGP> except we must also specify the number of runs.

When <repeatCGP> is called it prints high level information relating to each run to the terminal and returns an initialised <results> structure.  

(begin code)
rels = repeatCGP(params, trainingData, numGens, numRuns);
(end)

In order to access the result of applying CGP to a given task multiple times the returned <results> structure must be queried for information. For instance, <getAverageFitness>, <getAverageActiveNodes> and <getAverageGenerations> can be used to get the average fitness, average number of active nodes and average number of generations respectively. 

In the example code <getAverageFitness> is used to get the average fitness of all the runs which is then printed to the terminal.

(begin code)
averageFitness = getAverageFitness(rels);

printf("The average chromosome fitness is: %f\n", averageFitness);
(end)

As well as getting average statistics the best chromosome found on any given run can be accessed using <getChromosome>.

In the example code <getChromosome> is used to get the best chromosome found on run four which is then printed to the terminal using <printChromosome>.

(begin code)
chromo = getChromosome(rels, 4);

printf("The best chromosome found on run 4:\n");

printChromosome(chromo, 0);
(end)

In cases where the results need to be saved to be inspected later the <saveResults> function can be used. <saveResults> saves the given <results> structure to the given file. The format of the results is comma separated in the same form as is displayed to the terminal during <repeatCGP>; except the averages are not included.

(begin code)
saveResults(rels, "results.csv");
(end)

Finally all of the inilised strutures should be free'd including the <results> using <freeResults> and the <chromosome> returned from <getChromosome> using <freeChromosome>.

(begin code)
freeDataSet(trainingData);
freeChromosome(chromo);
freeResults(rels);
freeParameters(params);
(end)

And that's it, running CGP multiple times to assess its average performance is not that much more complicated that running it once.











