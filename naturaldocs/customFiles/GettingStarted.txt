Title: Getting Started   

This tutorial introduces and steps though a simple program which uses the CGP-Library to solve a simple symbolic regression problem.

Symbolic regression is the task of describing a series of data points using a mathematical equation. If you have not already downloaded and/or installed the CGP-Library please see the <Installation> tutorial. 

Title: The Program

A simple symbolic regression solving program used to illustrate the basic operation of the CGP-Library.

The program below is provided in the CGP-Library download within /examples/gettingStarted.c and is included in the code:blocks project.

(start code)
#include <stdio.h>
#include "../include/cgp.h"  

int main(void){

	struct parameters *params = NULL;
	struct dataSet *trainingData = NULL;
	struct chromosome *chromo = NULL;
		 
	int numInputs = 1;
	int numNodes = 15;
	int numOutputs = 1;
	int nodeArity = 2;
	
	int numGens = 10000;
	int updateFrequency = 500;  
	float targetFitness = 0.1;	
		
	params = initialiseParameters(numInputs, numNodes, numOutputs, nodeArity);
			
	addNodeFunction(params, "add,sub,mul,div,sin");
	
	setTargetFitness(params, targetFitness);
		
	setUpdateFrequency(params, updateFrequency);	
				
	printParameters(params);
	
	trainingData = initialiseDataSetFromFile("./examples/symbolic.data");
	
	chromo = runCGP(params, trainingData, numGens);	
			
	printChromosome(chromo);
	
	freeDataSet(trainingData);
	freeChromosome(chromo);		
	freeParameters(params);	
			
	return 0;
}
(end)


Title: Stepping Through the Code

A close look at each line of the example code.

First cgp.h must be included to use the CGP-Library. The location of cgp.h and where your complier looks for it will depend upon your personal set up.

(begin code)
#include "../include/cgp.h"  
(end)

The CGP-Library leaves memory management up to the user so as to allow 
the user more control. Structures are used to to store information 
relating to various aspect of the CGP-Library; These structures must be 
defined by the user but are initialised and free'd using provided 
functions. The <parameters> structure contains general information 
related to the CGP-Library and is used to pass information into other 
functions without requiring a long series of inputs. The <dataSet> structure is used to store any data which may be needed when evaluating chromosome fitnesses. For instance in this example it shall be used to store the data points to which CGP must fit an equation. The <chromosome> structure is used to store all the information relating to a single CGP chromosome instance.  

(begin code)
struct parameters *params = NULL;
struct dataSet *trainingData = NULL;
struct chromosome *chromo = NULL;
(end)

Later we will need to know the dimensions so these are assigned to 
variables. The number of inputs are the number of chromosome inputs. 
The number of nodes is the maximum number of chromosome nodes. The 
number of outputs is the number of chromosome outputs. The arity is 
the arity of each chromosome node.

(begin code)
int numInputs = 1;
int numNodes = 15;
int numOutputs = 1;
int nodeArity = 2;
(end)

We will also later need to specify the number of generations allowed 
before the search is terminated. 

(begin code)
int numGens = 10000; 
(end)


Although the parameters contain default values the user can also 
specify the target fitness and the frequency at which the user is shown 
the progress of the search. By default the target fitness is '0' and 
the user is shown the current best fitness at each generation. We will 
change these defaults later using the the values below.

(begin code)
float targetFitness = 0.1;	
int updateFrequency = 500; 
(end)

Next the parameters structure is initialised with default parameters 
and the chromosome dimensions defined earlier. This is achieved using 
<initialiseParameters>. 

(begin code)
params = initialiseParameters(numInputs, numNodes, numOutputs, nodeArity);
(end)

One of the roles of the parameters is to store a function set 
containing the functions which each node can implement. Newly initialised 
parameters contain a empty function set and it is up to the user to 
populate it. The functions are added to the function set using 
<addNodeFunction>. For a complete list of pre-defined functions see 
<addNodeFunction>. In order to remove a function from the function set 
the entire function set must be cleared using <clearFunctionSet> and 
then the desired functions re-added. 

The functions added here are: addition, subtraction, multiplication, 
division and sine.

(begin code)
addNodeFunction(params, "add,sub,mul,div,sin");
(end)

The default target fitness of '0' is altered using 
<setTargetFitness>. 

(begin code)
setTargetFitness(params, 0.1);
(end)

The default update frequency of '1' is altered using 
<setUpdateFrequency>.

(begin code)
setUpdateFrequency(params, updateFrequency);
(end)

If the user wishes to inspect the parameters currently set they can be 
printed to the terminal using <printParameters>.

(begin code)
printParameters(params);
(end)

When printed the parameters should appear as follows. Most of the 
parameters have been left as the defaults but the target fitness and 
update frequency have been altered. Additionally the function set 
contains the the functions we specified.

> ---------------------------------------------------
>                   Parameters                      
> ---------------------------------------------------
> Evolutionary Strategy:		(1+4)-ES
> Mutation Type:				probabilistic
> Mutation rate:				0.050000
> Connection weights range:		+/- 1.000000
> Fitness Function:				supervisedLearning
> Target Fitness:				0.100000
> Selection scheme:				pickFittest
> Reproduction scheme:			mutateRandomParent
> Update frequency:				500
> Function Set: add sub mul div sin (5)
> ---------------------------------------------------

Now the parameters associated with the CGP-Library are set up we next 
need to define the task to be solved. By default a supervised learning 
fitness function is used. The supervised learning fitness function
applies sets of user defined input output pairs to each chromosome 
and assigns a fitness proportional to how closely the chromosomes 
outputs match the desired correct outputs. The fitness used is the sum 
of the absolute differences between the generated and correct outputs 
over all given inputs.

Input output pairs are stored using the dataSet structure which 
contains the number of data samples and how many inputs and outputs 
each sample contains. 

One method of initialising a dataSet structure is to load the dataSet 
information from a file using <initialiseDataSetFromFile> which returns 
an initialised dataSet structure containing the data in the file 
specified.

Here we load in a data set containing 101 evenly sampled points from y 
= x^6 - 2x^4 + x^2 within the range [-5,5]. The data set is given in 
/examples/symbolic.data.

(begin code)
trainingData = initialiseDataSetFromFile("./examples/symbolic.data");
(end)

In order for <initialiseDataSetFromFile> to parse the data set the file must 
use the following format. Where the first line contains the number of inputs 
each sample uses followed by the number of outputs each sample uses 
followed by the total number of samples. The remaining lines each 
describe an individual sample giving the inputs values followed by the 
output values. All values must be comma separated.

>1,1,101,
>-5.000000,14400.000000,
>-4.900000,12712.338867,
>-4.800000,11191.949219,
>-4.700000,9825.367188,

Now we have set the CGP-Library <parameters> and gave specified the 
training <dataSet> we can run CGP. The <runCGP> function takes our defined 
parameters, training data and the number of generations allowed before 
terminating the search. The <runCGP> function also returns an 
initialised <chromosome> which represents the best solution to the given task.

Whilst CGP is running the current progress will be displayed to the 
terminal at the rate specified in the <parameters>.  

(begin code)
chromo = runCGP(params, trainingData, numGens);	
(end)

To inspect the best solution CGP found the returned <chromosome> can be 
printed to the terminal using <printChromosome>. 

(begin code)
printChromosome(chromo);
(end)

The printed chromosome take the following form. Each number line 
represents a node where a node can be an input node or a function 
node. Each function node is labelled with a textural description of what 
operation the node does. This is followed by pairs of number for each 
node input. Each pair gives the node to which that node input connects 
and a connection weight associated with that connection. As connection 
weights are only used when evolving neural networks then can be 
ignored in this example. Finally some function nodes are labelled with 
'*' indicating that it is a active node (it contribute the the overall 
operation of the evolved program).

> (0):	input
> (1):	mul	0,-0.0	0,+0.1	*
> (2):	mul	1,-0.7	1,-0.2	*
> (3):	sub	2,+0.2	1,+0.4	*
> (4):	add	2,+0.8	3,-0.1	*
> (5):	sub	3,-0.6	4,-0.1	*
> (6):	div	0,+0.0	1,-0.1	
> (7):	sub	0,-0.9	0,+0.8	
> (8):	add	1,+0.1	5,+0.6	*
> (9):	mul	3,+0.8	1,-0.1	*
> (10):	sin	2,-0.5	3,+0.2	
> (11):	sin	6,+0.3	0,+0.2	
> (12):	div	0,+0.9	9,-1.0	
> (13):	add	8,+0.8	9,-0.4	*
> (14):	mul	7,+0.9	7,+0.8	
> (15):	add	7,+0.3	3,+0.7	
> outputs: 13 

Finally the memory associated with the structures used should be 
free'd using <freeDataSet>, <freeChromosome> and <freeParameters>

(begin code)	
freeDataSet(trainingData);
freeChromosome(chromo);		
freeParameters(params);		
(end)

And that's it, in just 39 lines of code we have applied CGP to a 
symbolic regression task (and it could easily be done in less).

