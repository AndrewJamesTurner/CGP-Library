Title: Getting Started   

This tutorial introduces and steps though a simple program which uses the CGP-Library to solve a symbolic regression problem.

Symbolic regression is the task of fitting a symbolic equaltion to a
series of data points. If you have not already downloaded and/or installed the CGP-Library please see the <Installation> tutorial. 

Title: The Program

A simple symbolic regression solving program used to illustrate the basic operation of the CGP-Library.

The program below is provided in the CGP-Library download within /examples/gettingStarted.c and is included in the code:blocks project.

(start code)
#include <stdio.h>
#include "../include/cgp.h"  

int main(void){

	struct parameters *params = NULL;
	struct dataSet *trainingData = NULL;
	struct chromosome *chromo = NULL;
		 
	int numInputs = 1;
	int numNodes = 15;
	int numOutputs = 1;
	int nodeArity = 2;
	
	int numGens = 10000;
	int updateFrequency = 500;  
	float targetFitness = 0.1;	
		
	params = initialiseParameters(numInputs, numNodes, numOutputs, nodeArity);
			
	addNodeFunction(params, "add,sub,mul,div,sin");
	
	setTargetFitness(params, targetFitness);
		
	setUpdateFrequency(params, updateFrequency);	
				
	printParameters(params);
	
	trainingData = initialiseDataSetFromFile("./examples/symbolic.data");
	
	chromo = runCGP(params, trainingData, numGens);	
			
	printChromosome(chromo);
	
	freeDataSet(trainingData);
	freeChromosome(chromo);		
	freeParameters(params);	
			
	return 0;
}
(end)


Title: Stepping Through the Code

A close look at each line of the example code.

First cgp.h must be included to use the CGP-Library. The cgp.h is
located in the /include directory.

(begin code)
#include "../include/cgp.h"  
(end)

The CGP-Library provides a number of structures which describe, among
other things, the CGP parameters and CGP chromosomes. These parameters
are initialised and free'd using provided functions. The attributes of
these structures should not, and in fact cannot, be accessed directly
and must also be accessed using provided functions.

Below three CGP-Library structures which will be used later in this
tutorial.

The <parameters> structure will be used to store general CGP
parameters including the size of the chromosome, the evolutionary
strategy to use and the mutation rate.

The <dataSet> structure is used to store input output pairs of data
which may be used by the fitness function. For instance in this
example a <dataSet> structure will be used to store the data points to
which an equation should be fitted.

The <chromosome> structure is used to store the fittest chromosome
found after evolution towards the symbolic task.   

(begin code)
struct parameters *params = NULL;
struct dataSet *trainingData = NULL;
struct chromosome *chromo = NULL;
(end)

Later when we initialise the parameters structure using
<initialiseparameters> we will need to specify the structure of the
chromosomes to evolves. The involves specifying the number of
chromosome inputs, nodes, outputs and the arity of each node. 

(begin code)
int numInputs = 1;
int numNodes = 15;
int numOutputs = 1;
int nodeArity = 2;
(end)

Later when we apply CGP towards the symbolic task we will need to
specify the number of allowed generations before terminating the
search.

(begin code)
int numGens = 10000; 
(end)

Later when we initialise the <parameters> using <initialiseparameters>
many CGP-Library parameters will be set to typical default values.
However all of these CGP-Library parameters can be changed using
provided functions. This will be demonstrated by changing the default
target fitness and the frequency at which the user is updated on
progress.

(begin code)
float targetFitness = 0.1;	
int updateFrequency = 500; 
(end)

Now we actually initialise the <parameters> structure. As mentioned
<initialiseParameters> requires the user to specify the number of
chromosome inputs, nodes, outputs and each nodes arity.

Again as previously mentioned <initialiseParameters> sets the
CGP-Library parameters to typical default values.   

(begin code)
params = initialiseParameters(numInputs, numNodes, numOutputs, nodeArity);
(end)

One of the roles of the <parameters> structure is to store a function set 
which contains the set of possible node functions. Newly initialised 
parameters contain an empty function set and it is up to the user to 
populate this function set with node functions. Node functions are added
to the function set using <addNodeFunction>. For a complete list of
possible functions see <addNodeFunction>. To clear the functions
currently stored in the function use <clearFunctionSet>.

The functions added in this tutorial are: addition, subtraction, multiplication, 
division and sine.

(begin code)
addNodeFunction(params, "add,sub,mul,div,sin");
(end)

The default fitness function used by the CGP-Library is '0'. This
default target fitness can be altered using <setTargetFitness>.

(begin code)
setTargetFitness(params, 0.1);
(end)


The update frequency value defined in the <parameters> specifies the
number of generations which elapse between updating the user of the
progress made by CGP.

The default update frequency used by the CGP-Library is '1' generation. This
default value is altered using <setUpdateFrequency>.

(begin code)
setUpdateFrequency(params, updateFrequency);
(end)

The values stored in a <parameters> structure can be displed in the
terminal by calling <printParameters>.

(begin code)
printParameters(params);
(end)

When printed, the parameters should appear in the terminal as follows.
Most of the parameters have been left as the defaults but the target
fitness and update frequency have been altered. Additionally the
function set contains the the functions we specified.

For details of the parameters stored in <parameters> see <parameters>.

> ---------------------------------------------------
>                   Parameters                      
> ---------------------------------------------------
> Evolutionary Strategy:		(1+4)-ES
> Inputs:						1
> Nodes:						15
> Outputs:						1
> Node Arity:					2
> Connection weights range:		+/- 1.000000
> Mutation Type:				probabilistic
> Mutation rate:				0.050000
> Fitness Function:				supervisedLearning
> Target Fitness:				0.100000
> Selection scheme:				selectFittest
> Reproduction scheme:			mutateRandomParent
> Update frequency:				500
> Function Set: add sub mul div sin (5)
> ---------------------------------------------------


Now the parameters associated with the CGP-Library are set up we next 
need to define the task to be solved. By default a supervised learning 
fitness function is used. The supervised learning fitness function
applies sets of user defined input output pairs to each chromosome 
and assigns a fitness proportional to how closely the chromosomes 
outputs match the desired target outputs. The fitness used is the sum 
of the absolute differences between the generated and correct outputs 
over all given inputs.

Input output pairs are stored using <dataSet> structures which also
store meta data describing the number of data samples and how many
inputs and outputs each sample contains. 

One method of initialising a dataSet structure is to load the dataSet 
information from a predefined file using <initialiseDataSetFromFile>
which returns an initialised <dataSet> structure containing the data in
the file specified.

Here we load in a data set containing 101 evenly sampled points from y 
= x^6 - 2x^4 + x^2 within the range [-5,5]. The data set is given in
the /examples/symbolic.data directory.

(begin code)
trainingData = initialiseDataSetFromFile("./examples/symbolic.data");
(end)

In order for <initialiseDataSetFromFile> to parse the given file it must 
use the following format below. Where the first line contains the
number of inputs each sample uses followed by the number of outputs
each sample uses followed by the total number of samples. The remaining
lines describe individual samples giving the inputs values followed by
the output values. All values must be comma separated.

>1,1,101,
>-5.000000,14400.000000,
>-4.900000,12712.338867,
>-4.800000,11191.949219,
>-4.700000,9825.367188,

After we have set up a <parameters> structure and a <dataSet> structure we
now run CGP! This is achieved using the <runCGP> function.
<runCGP> takes as augments our defined parameters, the training
<dataSet> and the allowed number of generations before terminating the
search. The <runCGP> function returns an initialised <chromosome>
structure which contains the best found solution to the given task.

Whilst CGP is running the current progress will be displayed to the 
terminal at the update frequency specified in the <parameters>
structure.   

(begin code)
chromo = runCGP(params, trainingData, numGens);	
(end)

To inspect the best found solution the returned <chromosome> can be 
displayed in the terminal using <printChromosome>. 

(begin code)
printChromosome(chromo);
(end)

The printed chromosome take the following form. Each line starting
with an number represents a node; where a node can be an input node or
a function node. Each function node is labelled with a textural
description of the operation it undertakes i.e. 'add'. This is followed
by pairs of number for each node input. Each pair gives the node to
which that node input connects and a connection weight associated with
that connection. Connection weights are used when evolving neural
networks and can be ignored in this example. Finally some function
nodes are labelled with an '*' indicating that they are active in
calculating the outputs. 

> (0):	input
> (1):	mul	0,-0.0	0,+0.1	*
> (2):	mul	1,-0.7	1,-0.2	*
> (3):	sub	2,+0.2	1,+0.4	*
> (4):	add	2,+0.8	3,-0.1	*
> (5):	sub	3,-0.6	4,-0.1	*
> (6):	div	0,+0.0	1,-0.1	
> (7):	sub	0,-0.9	0,+0.8	
> (8):	add	1,+0.1	5,+0.6	*
> (9):	mul	3,+0.8	1,-0.1	*
> (10):	sin	2,-0.5	3,+0.2	
> (11):	sin	6,+0.3	0,+0.2	
> (12):	div	0,+0.9	9,-1.0	
> (13):	add	8,+0.8	9,-0.4	*
> (14):	mul	7,+0.9	7,+0.8	
> (15):	add	7,+0.3	3,+0.7	
> outputs: 13 

Finally the memory associated with the structures used should be 
free'd using <freeDataSet>, <freeChromosome> and <freeParameters>.

(begin code)	
freeDataSet(trainingData);
freeChromosome(chromo);		
freeParameters(params);		
(end)

And that's it, in just 39 lines of code we have applied CGP to a 
symbolic regression task (and it could easily be done in less).

